<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Untitled :: Jakarta EE Documentation</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../_/css/site.css">
    <script>var uiRootPath = '../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="../..">Jakarta EE Documentation</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="#">Home</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Products</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Product A</a>
            <a class="navbar-item" href="#">Product B</a>
            <a class="navbar-item" href="#">Product C</a>
          </div>
        </div>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Services</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="#">Service A</a>
            <a class="navbar-item" href="#">Service B</a>
            <a class="navbar-item" href="#">Service C</a>
          </div>
        </div>
        <div class="navbar-item">
          <span class="control">
            <a class="button is-primary" href="#">Download</a>
          </span>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jakarta-security-spec" data-version="3">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-explore is-active" data-panel="explore">
  <div class="context">
    <span class="title">Jakarta Security Specification</span>
    <span class="version">3</span>
  </div>
  <ul class="components">
    <li class="component">
      <a class="title" href="../../jakarta-ee-docs/current/index.html">Jakarta EE Documentation</a>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../jakarta-ee-docs/current/index.html">10</a>
        </li>
        <li class="version">
          <a href="../../jakarta-ee-docs/9.1/index.html">9.1</a>
        </li>
      </ul>
    </li>
    <li class="component is-current">
      <a class="title" href="security-spec.html">Jakarta Security Specification</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="security-spec.html">3</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../jakarta-ee-docs/current/index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
</nav>
  <div class="edit-this-page"><a href="file:///Users/kito/Core/Projects/eclipse.refresh.jakarta.ee.tutorial/vcs/security/spec/src/main/antora/modules/ROOT/pages/authenticationMechanism.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<div class="sect1">
<h2 id="authentication-mechanism"><a class="anchor" href="#authentication-mechanism"></a>Authentication Mechanism</h2>
<div class="sectionbody">
<div class="paragraph">
<p>This chapter describes the <em>HttpAuthenticationMechanism</em> interface and contract. <em>HttpAuthenticationMechanism</em> is used to authenticate callers of web applications, and is specified only for use in the servlet container. It is explicitly not defined for use with other containers (enterprise beans, messaging, connectors, etc.).</p>
</div>
<div class="sect2">
<h3 id="_introduction"><a class="anchor" href="#_introduction"></a>Introduction</h3>
<div class="paragraph">
<p>A web application consists of resources that can be accessed by any number of callers, who are initially unknown to the application. Callers make themselves known to the application through the process of authentication.</p>
</div>
<div class="paragraph">
<p>During authentication, the caller presents proof of identity&#8201;&#8212;&#8201;a token or credential of some kind&#8201;&#8212;&#8201;which the application (or container) then validates. If the proof is valid, the application (or container) establishes the caller&#8217;s identity, then proceeds to the authorization step, in which it determines whether the caller has permission to access the requested resources.</p>
</div>
<div class="paragraph">
<p>In some cases (for example, username/password authentication) the interaction between the caller and the application is simple. In other cases, a lengthier dialog is required&#8201;&#8212;&#8201;an application may send a random nonce to the caller, which must then use that nonce in the construction of an authentication token, or there may be interactions with a third party that vouches for the caller&#8217;s identity, or the authenticity of the provided credential.</p>
</div>
<div class="paragraph">
<p>The Jakarta EE Platform already specifies mechanisms for authenticating users of web applications. The Jakarta Servlet Specification, version 4.0 [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>] specifies a declarative mechanism for configuring an application to provide BASIC, DIGEST, FORM, or CERT authentication, with authentication performed automatically by the container based on the application&#8217;s configuration, which, in the case of FORM authentication, can include custom form pages.</p>
</div>
<div class="paragraph">
<p>In addition, The Jakarta Authentication Specification, version 3.0 [<a href="https://jakarta.ee/specifications/authentication/3.0/">AUTHENTICATION30</a>] specifies a general-purpose mechanism for securing messages sent between Jakarta EE clients and servers. Jakarta Authentication defines an SPI called <em>ServerAuthModule</em>, which enables development of authentication modules to handle any credential type, or engage in interaction of arbitrary complexity with clients and third parties. [<a href="https://jakarta.ee/specifications/authentication/3.0/">AUTHENTICATION30</a>] also defines the Servlet Container Profile, which specifies how Jakarta Authentication mechanisms, including <em>ServerAuthModules</em>, are integrated with the servlet container.</p>
</div>
<div class="paragraph">
<p>While both existing mechanisms are important and useful, each has limitations from the point of view of an application developer. The servlet container&#8217;s <em>login-config</em> mechanism is limited to the <em>auth-method</em> types defined by [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>]&#8201;&#8212;&#8201;it doesn&#8217;t support other credential types, or complex interactions with callers. It also relies on unspecified container mechanisms to associate identity stores with applications. There is no way for an application to ensure that callers are authenticated against the desired identity store, or, indeed, against <em>any</em> identity store.</p>
</div>
<div class="paragraph">
<p>Jakarta Authentication, by way of contrast, is extremely flexible and powerful, but is also complex. Writing an <em>AuthModule</em>, and arranging for the web container to use it for authentication, is a non-trivial exercise. Additionally, there is no declarative configuration syntax for Jakarta Authentication, and there is no well-defined mechanism for a container to override an application&#8217;s programmatically-registered <em>AuthModule</em>. A container can choose to register its own <em>AuthModule</em>, or to remove one registered by an application, but Jakarta Authentication will always use the most-recently-registered module&#8201;&#8212;&#8201;the outcome is dependent on the order in which the application and the container attempt to register their respective modules.</p>
</div>
<div class="paragraph">
<p>The <em>HttpAuthenticationMechanism</em> interface is designed to capitalize on the strengths of existing authentication mechanisms, while mitigating the corresponding limitations. It is essentially a simplified, servlet-container-specific version of the Jakarta Authentication <em>ServerAuthModule</em> interface, retaining that interface&#8217;s flexibility and power, but reducing the cost of implementation. An <em>HttpAuthenticationMechanism</em> is a CDI bean, and is therefore made available to the container automatically by CDI. The container is responsible for placing the <em>HttpAuthenticationMechanism</em> in service.</p>
</div>
<div class="paragraph">
<p>An application MAY supply its own <em>HttpAuthenticationMechanism</em>, if desired. The servlet container MUST provide several default <em>HttpAuthenticationMechanism</em> implementations, which an application can select and configure via standard annotations. The container MAY also provide additional mechanisms beyond those required by this specification. The rules governing how the container selects an <em>HttpAuthenticationMechanism</em>, and how it is placed in service, are described in the "<a href="#_installation_and_configuration">Installation and Configuration</a>" section of this chapter. The required default mechanisms, and corresponding annotations, are described in the "<a href="#_annotations_and_built_in_httpauthenticationmechanism_beans">Annotations and Built-In HttpAuthenticationMechanism Beans</a>" section.</p>
</div>
</div>
<div class="sect2">
<h3 id="_interface_and_theory_of_operation"><a class="anchor" href="#_interface_and_theory_of_operation"></a>Interface and Theory of Operation</h3>
<div class="paragraph">
<p>The <em>HttpAuthenticationMechanism</em> interface defines three methods that align closely with the methods defined by the Jakarta Authentication <em>ServerAuth</em> interface. The primary distinction is syntactic; unlike Jakarta Authentication, <em>HttpAuthenticationMechanism</em> is specified for the servlet container only, and can therefore reference servlet types in its method signatures. Only the <em>validateRequest()</em> method must be implemented; default behaviors are specified for the other two methods.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">AuthenticationStatus validateRequest(HttpServletRequest request,
                                     HttpServletResponse response,
                                     HttpMessageContext httpMessageContext
                                    ) throws AuthenticationException;

AuthenticationStatus secureResponse(HttpServletRequest request,
                                    HttpServletResponse response,
                                    HttpMessageContext httpMessageContext
                                   ) throws AuthenticationException;

void cleanSubject(HttpServletRequest request,
                  HttpServletResponse response,
                  HttpMessageContext httpMessageContext);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each method performs the same function as the corresponding <em>ServerAuth</em> method. At runtime, the methods will be invoked by a container-supplied <em>ServerAuthModule</em> that serves as a wrapper, or container, for the <em>HttpAuthenticationMechanism</em>. The container-supplied <em>ServerAuthModule</em> translates the method parameters passed to it, invokes the <em>HttpAuthenticationMechanism</em> method, and returns the resulting status to its caller. The behavior of the <em>HttpAuthenticationMechanism</em> methods should therefore be functionally equivalent to the behavior specified by the Jakarta Authentication Servlet Container Profile for the equivalent <em>ServerAuthModule</em> methods.</p>
</div>
<div class="paragraph">
<p>Summarized, this means:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>validateRequest()</em> will be invoked before the <em>doFilter()</em> method of any servlet filter or the <em>service()</em> method of any servlet in the application for requests to constrained as well as to unconstrained resources, and, in addition, in response to application code calling the <em>authenticate()</em> method on the <em>HttpServletRequest</em>.</p>
</li>
<li>
<p><em>secureResponse()</em> will be invoked after the <em>doFilter()</em> method of any servlet filter or the <em>service()</em> method of any servlet in the application for requests to constrained as well as to unconstrained resources, but only if any of these two methods have indeed been invoked.</p>
</li>
<li>
<p><em>cleanSubject()</em> will be invoked in response to the application calling the <em>logout()</em> method on the <em>HttpServletRequest</em>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <em>validateRequest()</em> method is provided to allow a caller to authenticate. An implementation of this method can inspect the HTTP request to extract a credential or other information, or it can write to the HTTP response to, for example, redirect a caller to an OAuth provider, or return an error response. After a credential has been obtained and validated, the result of the validation can be communicated to the container using the <em>HttpMessageContext</em> parameter, which is described in more detail below.</p>
</div>
<div class="paragraph">
<p>The <em>secureResponse()</em> method is provided to allow post processing on the response generated by a servlet and/or servlet filter, such as encrypting it.</p>
</div>
<div class="paragraph">
<p>The <em>cleanSubject()</em> is provided to allow for cleanup after a caller is logged out. For example, an authentication mechanism that stores state within a cookie can remove that cookie here.</p>
</div>
<div class="paragraph">
<p>The <em>HttpMessageContext</em> interface defines methods that an <em>HttpAuthenticationMechanism</em> can invoke to communicate with the Jakarta Authentication <em>ServerAuthModule</em> (bridge module) that invokes it. The container MUST provide an implementation of the interface that supports the necessary container integrations.</p>
</div>
<div class="paragraph">
<p>The <em>HttpMessageContextWrapper</em> class implements a wrapper that can be used, in a manner similar to <em>HttpServletRequestWrapper</em>, to provide custom behavior.</p>
</div>
<div class="paragraph">
<p>See javadoc for a detailed description of <em>HttpMessageContext</em> and <em>HttpMessageContextWrapper</em>. See below for more on the Jakarta Authentication bridge module.</p>
</div>
</div>
<div class="sect2">
<h3 id="_installation_and_configuration"><a class="anchor" href="#_installation_and_configuration"></a>Installation and Configuration</h3>
<div class="paragraph">
<p>An <em>HttpAuthenticationMechanism</em> must be a CDI bean, and is therefore visible to the container through CDI if it is packaged in a bean archive, which generally includes Jakarta EE modules and application archives, as well as other archives and classes that are not part of an application, but are required by the Jakarta EE specification to be visible to applications. See the CDI specification for details on bean archives and bean discovery. An <em>HttpAuthenticationMechanism</em> is assumed to be normal scoped.</p>
</div>
<div class="paragraph">
<p>It MUST be possible for the definition of an <em>HttpAuthenticationMechanism</em> to exist within the application archive. Alternatively such definition MAY also exists outside the application archive, for example in a jar added to the classpath of an application server.</p>
</div>
<div class="paragraph">
<p>An application packages its own <em>HttpAuthenticationMechanism</em> by including in a bean archive that is part of the application. Alternatively, it may select and configure one of the container&#8217;s built-in mechanisms using the corresponding annotation, as described in the "<a href="#_annotations_and_built_in_httpauthenticationmechanism_beans">Annotations and Built-In HttpAuthenticationMechanism Beans</a>" section below.</p>
</div>
<div class="paragraph">
<p>The container decides which <em>HttpAuthenticationMechanism</em> to place in service using the following rules:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The container MAY override an application&#8217;s chosen <em>HttpAuthenticationMechanism</em> with one selected by the container, but SHOULD do so only if explicitly configured to.</p>
</li>
<li>
<p>If the container does not override the application, it MUST place in service any <em>HttpAuthenticationMechanism</em> that is provided, either directly or via annotation, by the application.</p>
</li>
<li>
<p>If the application makes more than one <em>HttpAuthenticationMechanism</em> available, either directly or via annotation or both, the results are undefined by this specification.</p>
</li>
<li>
<p>If the application does not supply an <em>HttpAuthenticationMechanism</em>, or select one of the built-in mechanisms, the container MAY choose an <em>HttpAuthenticationMechanism</em> to place in service, but is NOT REQUIRED to do so.</p>
</li>
<li>
<p>If the application does not make an <em>HttpAuthenticationMechanism</em> available, and the container does not choose one to place in service, then <em>HttpAuthenticationMechanism</em> is not used.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The container MUST use Jakarta Authentication when placing an <em>HttpAuthenticationMechanism</em> in service. The container MUST supply a "bridge" <em>ServerAuthModule</em> that integrates <em>HttpAuthenticationMechanism</em> with Jakarta Authentication. The bridge module MUST look up the correct <em>HttpAuthenticationMechanism</em> using CDI, then delegate to the <em>HttpAuthenticationMechanism</em> when the bridge module&#8217;s methods are invoked. Since the method signatures and return values of the two interfaces are similar, but not the same, the bridge module MUST convert back and forth.</p>
</div>
<div class="paragraph">
<p>When an <em>HttpAuthenticationMechanism</em> is placed in service, the container MUST supply a bridge <em>ServerAuthModule</em> and the necessary supporting modules (<em>AuthContext</em>, <em>AuthConfig</em>, <em>AuthConfigProvider</em>), and arrange for the <em>AuthConfigProvider</em> to be registered with the Jakarta Authentication <em>AuthConfigFactory</em>, such that the bridge module is registered for the application context.</p>
</div>
<div class="paragraph">
<p>When an <em>HttpAuthenticationMechanism</em> is placed in service, the container MUST NOT register any <em>AuthConfigProvider</em> other than the one corresponding to the bridge <em>ServerAuthModule</em>. Given the nature of Jakarta Authentication, however, it&#8217;s possible that some other entity could register a different <em>AuthConfigProvider</em> after the container has registered the bridge module&#8217;s <em>AuthConfigProvider</em>. The container is NOT REQUIRED to prevent this.</p>
</div>
</div>
<div class="sect2">
<h3 id="_annotations_and_built_in_httpauthenticationmechanism_beans"><a class="anchor" href="#_annotations_and_built_in_httpauthenticationmechanism_beans"></a>Annotations and Built-In HttpAuthenticationMechanism Beans</h3>
<div class="paragraph">
<p>A Jakarta EE container MUST support built-in beans for the following <em>HttpAuthenticationMechanism</em> types, to be made available via configuration:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>BASIC - Authenticates according to the mechanism as described in 13.6.1, "HTTP Basic Authentication", in [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>]. See also RFC 7617, "The 'Basic' HTTP Authentication Scheme" [<a href="https://tools.ietf.org/html/rfc7617">RFC7617</a>]. This bean is activated and configured via the <em>@BasicAuthenticationMechanismDefinition</em> annotation.</p>
</li>
<li>
<p>FORM - Authenticates according to the mechanism as described in 13.6.3, "Form Based Authentication", in [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>]. This bean is activated and configured via the <em>@FormAuthenticationMechanismDefinition</em> annotation.</p>
</li>
<li>
<p>Custom FORM - A variant on FORM, with the difference that continuing the authentication dialog as described in [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>], section 13.6.3, step 3, and further clarified in section 13.6.3.1, does not happen by posting back to j_security_check, but by invoking <em>SecurityContext.authenticate()</em> with the credentials the application collected. This bean is activated and configured via the <em>@CustomFormAuthenticationMechanismDefinition</em> annotation.</p>
</li>
<li>
<p>OpenID Connect - Authenticates according to the Authorization Code flow and Refresh tokens as defined by the OpenID Connect specification. See [<a href="https://openid.net/specs/openid-connect-core-1_0.html#CodeFlowAuth">OPENID10FLOW</a>] and [<a href="https://openid.net/specs/openid-connect-core-1_0.html#RefreshTokens">OPENID10REFRESH</a>]. This bean is activated and configured via the <em>@OpenIdAuthenticationMechanismDefinition</em> annotation.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>All of these beans MUST have the qualifier @Default and the scope @ApplicationScoped, as defined by the CDI specification.</p>
</div>
<div class="paragraph">
<p>All of the built-in beans MUST support authentication using <em>IdentityStore</em>, described in Chapter 3, "<a href="identityStore.html#identity-store" class="xref page">Identity Store</a>", but MAY fall-back to container-specific methods if no <em>IdentityStore</em> is available.</p>
</div>
<div class="paragraph">
<p>See also the "<a href="#_implementation_notes">Implementation Notes</a>" section of this chapter.</p>
</div>
<div class="paragraph">
<p>The annotations are defined as shown in the following sections.</p>
</div>
<div class="sect3">
<h4 id="_basic_annotation"><a class="anchor" href="#_basic_annotation"></a>BASIC Annotation</h4>
<div class="paragraph">
<p>The following annotation is used to configure the built-in BASIC authentication mechanism.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RUNTIME)
@Target(TYPE)
public @interface BasicAuthenticationMechanismDefinition {

    /**
     * Name of realm that will be sent via the &lt;code&gt;WWW-Authenticate&lt;/code&gt; header.
     * &lt;p&gt;
     * Note that this realm name &lt;b&gt;does not&lt;/b&gt; couple a named identity store
     * configuration to the authentication mechanism.
     *
     * @return Name of realm
     */
    String realmName() default "";
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_form_annotation"><a class="anchor" href="#_form_annotation"></a>FORM Annotation</h4>
<div class="paragraph">
<p>The following annotation is used to configure the built-in FORM authentication mechanism.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RUNTIME)
@Target(TYPE)
public @interface FormAuthenticationMechanismDefinition {

    @Nonbinding
    LoginToContinue loginToContinue();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the "<a href="#_logintocontinue_annotation">LoginToContinue Annotation</a>" section below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_form_annotation"><a class="anchor" href="#_custom_form_annotation"></a>Custom FORM Annotation</h4>
<div class="paragraph">
<p>The following annotation is used to configure the built-in Custom FORM authentication mechanism.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Retention(RUNTIME)
@Target(TYPE)
public @interface CustomFormAuthenticationMechanismDefinition {

    @Nonbinding
    LoginToContinue loginToContinue();
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>See also the "<a href="#_logintocontinue_annotation">LoginToContinue Annotation</a>" and "<a href="#_custom_form_notes">Custom FORM Notes</a>" sections below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_openid_connect_annotation"><a class="anchor" href="#_openid_connect_annotation"></a>OpenID Connect Annotation</h4>
<div class="paragraph">
<p>The following annotation is used to configure the built-in OpenID Connect authentication mechanism.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Target({TYPE, METHOD})
@Retention(RUNTIME)
public @interface OpenIdAuthenticationMechanismDefinition {

    /**
     * Required, unless providerMetadata is specified.
     * The provider URI to read / discover the metadata of the openid provider.
     *
     * @see http://openid.net/specs/openid-connect-discovery-1_0.html
     *
     * @return provider URI to read from which to read metadata
     */
    String providerURI() default "";

    /**
     * To override the openid connect provider's metadata property discovered
     * via providerUri.
     *
     * @return OpenIdProviderMetadata instance.
     */
    OpenIdProviderMetadata providerMetadata() default @OpenIdProviderMetadata;

    /**
     * Required. The client identifier issued when the application was
     * registered.
     *
     * @return the client identifier
     */
    String clientId() default "";

    /**
     * Required. The client secret.
     *
     * &lt;p&gt;
     * Note that it is strongly recommended to set this using an Expression so that the value
     * is not hardcoded within the code.
     *
     * @return The client secret
     */
    String clientSecret() default "";

    /**
     * Optional. The claims definition defines the custom claims mapping of
     * caller name and groups.
     *
     * @return
     */
    ClaimsDefinition claimsDefinition() default @ClaimsDefinition;

    /**
     * Optional. The Logout definition defines the logout and Relaying Party session
     * management configuration.
     *
     * @return
     */
    LogoutDefinition logout() default @LogoutDefinition;

    /**
     * The redirect URI (callback URI) to which the response will be sent by the OpenId
     * Connect Provider. This URI must exactly match one of the Redirection URI values
     * for the Client pre-registered at the OpenID Provider.
     *
     * @return
     */
    String redirectURI() default "${baseURL}/Callback";

    /**
     * Optional. Automatically redirects the caller (the end-user) from
     * the redirect URI defined by the &lt;code&gt;redirectURI&lt;/code&gt; attribute
     * to the resource the end-user originally requested in a "login to continue"
     * scenario.
     *
     * &lt;p&gt;
     * After arriving at the original requested resource, the runtime restores
     * the request as it originally happened, including cookies, headers, the
     * request method and the request parameters in the same way as done when
     * using the {@link LoginToContinue} feature.
     *
     * @return
     */
    boolean redirectToOriginalResource() default false;

    /**
     * Optional. Allows the &lt;code&gt;redirectToOriginalResource&lt;/code&gt; to be specified as
     * Jakarta Expression Language expression.
     * If set, overrides the value defined by the &lt;code&gt;redirectToOriginalResource&lt;/code&gt; value.
     *
     * @return
     */
    String redirectToOriginalResourceExpression() default "";

    /**
     * Optional. The scope value defines the access privileges. The basic (and
     * required) scope for OpenID Connect is the openid scope.
     *
     * @return
     */
    String[] scope() default {OPENID_SCOPE, EMAIL_SCOPE, PROFILE_SCOPE};

    /**
     * Optional. Allows The scope value to be specified as Jakarta Expression Language expression.
     * If Set, overrides any values set by scope.
     *
     * @return
     */
    String scopeExpression() default "";

    /**
     * Optional. Response Type value defines the processing flow to be used. By
     * default, the value is code (Authorization Code Flow).
     *
     * @return
     */
    String responseType() default CODE;

    /**
     * Optional. Informs the Authorization Server of the mechanism to be used
     * for returning parameters from the Authorization Endpoint.
     *
     * @return
     */
    String responseMode() default "";

    /**
     * Optional. The prompt value specifies whether the authorization server
     * prompts the user for reauthentication and consent. If no value is
     * specified and the user has not previously authorized access, then the
     * user is shown a consent screen.
     *
     * @return
     */
    PromptType[] prompt() default {};

    /**
     * Optional. Allows the  prompt value to be specified as Jakarta Expression Language expression.
     * If Set, overirdes the value defined by the prompt value.
     *
     * @return
     */
    String promptExpression() default "";

    /**
     * Optional. The display value specifying how the authorization server
     * displays the authentication and consent user interface pages.
     *
     * @return
     */
    DisplayType display() default DisplayType.PAGE;

    /**
     * Optional. Allows the display value to be specified as Jakarta Expression Language expression.
     * If set, overrides the value defined by display.
     *
     * @return
     */
    String displayExpression() default "";

    /**
     * Optional. Enables string value used to mitigate replay attacks.
     *
     * @return
     */
    boolean useNonce() default true;

    /**
     * Optional. Allows the nonce activation to be specified as Jakarta Expression Language expression.
     * If set, overrides the value defined by the useNonce value.
     *
     * @return
     */
    String useNonceExpression() default "";

    /**
     * Optional. If enabled the state, nonce values and original requested resource data are stored in an HTTP session
     * otherwise in cookies.
     *
     * @return
     */
    boolean useSession() default true;

    /**
     * Optional. Allows the configuration of the session through a Jakarta Expression Language expression.
     * If set, overwrites the value of useSession value.
     *
     * @return
     */
    String useSessionExpression() default "";

    /**
     * An array of extra options that will be sent to the OAuth provider.
     * &lt;p&gt;
     * These must be in the form of {@code "key=value"} i.e.
     * &lt;code&gt; extraParameters={"key1=value", "key2=value2"} &lt;/code&gt;
     *
     * @return
     */
    String[] extraParameters() default {};

    /**
     * Allows the extra parameters to be defined as a Jakarta Expression Language expression.
     * If set, overrides the extraParameters value.
     *
     * @return
     */
    String extraParametersExpression() default "";

    /**
     * Optional. Sets the connect timeout(in milliseconds) for Remote JWKS
     * retrieval. Value must not be negative and if value is zero then infinite
     * timeout.
     *
     * @return
     */
    int jwksConnectTimeout() default 500;

    /**
     * Optional. Allows the connect timeout(in milliseconds) for Remote JWKS to be defined as
     * Jakarta Expression Language expression.
     * If set, overwrites the  jwksConnectTimeout value.
     *
     * @return
     */
    String jwksConnectTimeoutExpression() default "";

    /**
     * Optional. Sets the read timeout(in milliseconds) for Remote JWKS
     * retrieval. Value must not be negative and if value is zero then infinite
     * timeout.
     *
     * @return
     */
    int jwksReadTimeout() default 500;

    /**
     * Optional. Allows the read timeout(in milliseconds) for Remote JWKS
     * retrieval to be defined as Jakarta Expression Language expression.
     * If set, overwrites the jwksReadTimeout value.
     *
     * @return
     */
    String jwksReadTimeoutExpression() default "";

    /**
     * Optional. Enables or disables the automatically performed refresh of
     * Access and Refresh Token.
     *
     * @return {@code true}, if Access and Refresh Token shall be refreshed
     * automatically when they are expired.
     */
    boolean tokenAutoRefresh() default false;

    /**
     * Optional. Allows the automatically performed refresh of
     * Access and Refresh Token to be defined as Jakarta Expression Language expression.
     * If set, overwrites the value of  tokenAutoRefresh.
     */
    String tokenAutoRefreshExpression() default "";

    /**
     * Optional. Sets the minimum validity time in milliseconds the Access Token
     * must be valid before it is considered expired. Value must not be
     * negative.
     *
     * @return
     */
    int tokenMinValidity() default 10 * 1000;

    /**
     * Optional. Allows the minimum validity time in milliseconds the Access Token
     * must be valid before it is considered expired to be defined as Jakarta Expression Language expression.
     * If Set, overwrites the tokenMinValidity value.
     *
     * @return
     */
    String tokenMinValidityExpression() default "";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>Attributes of this annotation, as well as in the annotations referenced from them (e.g. <code>OpenIdProviderMetadata</code>),  support Jakarta Expression Language evaluation as specified in <a href="#Jakarta Expression Language Support">[Jakarta Expression Language Support]</a>.</p>
</div>
<div class="paragraph">
<p>The expected behavior is defined in the following sections.</p>
</div>
<div class="sect4">
<h5 id="_metadata_configuration"><a class="anchor" href="#_metadata_configuration"></a>Metadata configuration</h5>
<div class="paragraph">
<p>The OpenID Connect authentication mechanism needs metadata about the OpenID Connect Provider to function properly. The OpenID Connect specification defines that this data can be read from the <code>well known openid configuration endpoint</code> which resides at <code>[OpenID Connect Provider base URL].well-known/openid-configuration</code>.</p>
</div>
<div class="paragraph">
<p>The following metadata values are required (since they are defined as required by the OpenID Specification):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Authorization endpoint</p>
</li>
<li>
<p>Token endpoint</p>
</li>
<li>
<p>JWKS URI</p>
</li>
<li>
<p>Issuer of the tokens</p>
</li>
<li>
<p>Supported Subject types</p>
</li>
<li>
<p>Supported Response types</p>
</li>
<li>
<p>Supported Id Token Signing Algorithms</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>OpenIdAuthenticationMechanismDefinition.providerURI</code> defines the base URL of the OpenID Connect Provider where the <code>/.well-known/openid-configuration</code> is appended to (or used as-is when it is the well known configuration URL itself). Reading the <code>well known openid configuration endpoint</code> can be done eagerly when the application is deployed or lazily at the time a secured URL is accessed for the first time. The values retrieved from the <code>well known openid configuration endpoint</code> can be overwritten if needed by using the <code>OpenIdAuthenticationMechanismDefinition.providerMetadata</code> structure.</p>
</div>
</div>
<div class="sect4">
<h5 id="_authentication_dialog"><a class="anchor" href="#_authentication_dialog"></a>Authentication dialog</h5>
<div class="paragraph">
<p>The authentication dialog that the authentication mechanism starts and coordinates follows the flow as defined by the OpenID Connect specification. For
completeness this is depicted below:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-text hljs" data-lang="text"> *  +--------+                                                       +--------+
 *  |        |                                                       |        |
 *  |        |---------------(1) Authentication Request-------------&gt;|        |
 *  |        |                                                       |        |
 *  |        |       +--------+                                      |        |
 *  |        |       |  End-  |&lt;--(2) Authenticates the End-User----&gt;|        |
 *  |   RP   |       |  User  |                                      |   OP   |
 *  |        |       +--------+                                      |        |
 *  |        |                                                       |        |
 *  |        |&lt;---------(3) Returns Authorization code---------------|        |
 *  |        |                                                       |        |
 *  |        |---------(3b)                                          |        |
 *  |        |           | Redirect to original resource (if any)    |        |
 *  |        |&lt;----------+                                           |        |
 *  |        |                                                       |        |
 *  |        |------------------------------------------------------&gt;|        |
 *  |        |   (4) Request to TokenEndpoint for Access / Id Token  |        |
 *  | OpenID |&lt;------------------------------------------------------| OpenID |
 *  | Connect|                                                       | Connect|
 *  | Client | -----------------------------------------------------&gt;|Provider|
 *  |        |   (5) Fetch JWKS to validate ID Token                 |        |
 *  |        |&lt;------------------------------------------------------|        |
 *  |        |                                                       |        |
 *  |        |------------------------------------------------------&gt;|        |
 *  |        |   (6) Request to UserInfoEndpoint for End-User Claims |        |
 *  |        |&lt;------------------------------------------------------|        |
 *  |        |                                                       |        |
 *  +--------+                                                       +--------+</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the authentication mechanism determines authentication is required, for instance when the caller ("end-user" in OpenID Connect terminology) tries to access a protected resource without being authenticated, or when the caller explicitly initiates authentication, without being authenticated for the current request, an authentication request needs to be assembled and send to the authentication endpoint of the OpenID Connect provider. This request corresponds to step (1) in the OpenID Connect diagram depicted above. The location of this endpoint is configured by the <code>providerURI</code> attribute of the <code>OpenIdAuthenticationMechanismDefinition</code> annotation.</p>
</div>
<div class="paragraph">
<p>The following values need to be passed to this endpoint <em>unconditionally</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>ClientId value as taken from <code>OpenIdAuthenticationMechanismDefinition.clientId</code></p>
</li>
<li>
<p>Scope value as taken from <code>OpenIdAuthenticationMechanismDefinition.scope</code></p>
</li>
<li>
<p>Response Type value as taken from <code>OpenIdAuthenticationMechanismDefinition.responseType</code></p>
</li>
<li>
<p>State value, must be generated by the authentication mechanism</p>
</li>
<li>
<p>RedirectURI value as taken from <code>OpenIdAuthenticationMechanismDefinition.redirectURI</code> (evaluated)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>redirectURI</code> attribute of the <code>OpenIdAuthenticationMechanismDefinition</code> annotation may contain a Jakarta Expression Language expression with a variable <code>baseURL</code> which is resolved to the host and context path of the application for which the OpenID Connect authentication mechanism is installed. This requirement makes it easier to have an absolute URL as required by the OpenID Connect specification. Examples of <code>redirectURI</code> values:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>redirectURI = "${baseURL}/Callback"</code> - concatenates the <code>baseURL</code> variable and the "/Callback" string in a composite expression.</p>
</li>
<li>
<p><code>redirectURI = "${baseURL += oidcConfig.redirectCallback}"</code> - concatenates the <code>baseURL</code> variable and the <code>redirectCallback</code> property on bean <code>oidcConfig</code> in a single expression</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following values need to be passed to this endpoint <em>conditionally</em>:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Nonce, must be generated by the authentication mechanism if <code>OpenIdAuthenticationMechanismDefinition.useNonce</code> is set to <code>true</code></p>
</li>
<li>
<p>Response Mode value as taken from <code>OpenIdAuthenticationMechanismDefinition.responseMode</code> if defined</p>
</li>
<li>
<p>Display value as taken from <code>OpenIdAuthenticationMechanismDefinition.display</code> if defined</p>
</li>
<li>
<p>Prompt value as taken from <code>OpenIdAuthenticationMechanismDefinition.prompt</code> if defined</p>
</li>
<li>
<p>Extra values as taken from <code>OpenIdAuthenticationMechanismDefinition.extraParameters</code> if defined</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The State value, and also the Nonce value if requested, MUST be stored between requests so that these values can be validated when the OpenID Connect Provider later calls the supplied redirectURI. These values can either be stored serverside (in the HTTP Session) or clientside (as a Cookie). The value of the <code>OpenIdAuthenticationDefinition.useSession</code> attribute determines which one is used. In the case of storage through a Cookie, the Cookie must be defined as <code>HTTPonly</code> and must have the <code>Secure</code> flag set.</p>
</div>
<div class="paragraph">
<p>Before the redirect to the authentication endpoint of the OpenID Connect Provider is performed, the URL plus request parameters requested by the caller on which the authentication dialog was triggered must be stored so that it later on can be retrieved by a call to <code>OpenIdContext.getStoredValue(request, response, OpenIdConstant.ORIGINAL_REQUEST)</code>.</p>
</div>
<div class="paragraph">
<p>Additionally, if <code>OpenIdAuthenticationMechanismDefinition.redirectToOriginalResource</code> is set to 'true' and the authentication flow is container-initiated (as opposed to caller-initiated authentication) the authentication mechanism must store the full request as well. The full request here means all data that makes up the <code>HttpServletRequest</code> so that the container can restore this request later on in a similar way to how the "<a href="#_logintocontinue_annotation">LoginToContinue Annotation</a>" behaves.</p>
</div>
<div class="paragraph">
<p>Step (3) in the OpenID Connect diagram depicted above, that is, when the OpenID Connect Provider calls us back, is detected by the authentication mechanism when a request contains a <code>state</code> request parameter. When that initial condition is satisfied, the following investigation and actions must be done by the authentication mechanism:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the request (without request parameters) does not match the <code>redirectURI</code>, or does not match the stored original URL (without request parameters) in case <code>AuthenticationMechanismDefinition.redirectToOriginalResource</code> is set to 'true', it must reply with a <code>CredentialValidationResult.NOT_VALIDATED_RESULT</code> value.</p>
</li>
<li>
<p>If there is no State value stored, it must reply with a <code>CredentialValidationResult.NOT_VALIDATED_RESULT</code> value.</p>
</li>
<li>
<p>If the State value in the request does not match the State value stored, it must reply with a <code>CredentialValidationResult.INVALID_RESULT</code> value.</p>
</li>
<li>
<p>If the request contains a parameter <code>error</code>, the authentication by the OpenID Connect Provider has failed and the authentication mechanism must reply with a <code>CredentialValidationResult.INVALID_RESULT</code> value.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If none of the above listed additional conditions apply, the request is taken to be a valid callback and the authentication between the end-user (caller) and the OpenID Connect Provider is considered to have been successful. The authentication mechanism must now move to step (4) of the OpenID Connect diagram and mark this internally by clearing the stored State value (remove it from the HTTP session or Cookie).</p>
</div>
<div class="paragraph">
<p>For step (4) the authentication mechanism itself must call the Token endpoint to retrieve an Access Token and ID Token. This constitutes a so-called server to server call, as the end-user (caller) MUST NOT be involved here.</p>
</div>
<div class="paragraph">
<p>The call to the token endpoint must include the following parameters (as specified by the OpenID Connect specification):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The ClientId value as taken from <code>OpenIdAuthenticationMechanismDefinition.clientId</code></p>
</li>
<li>
<p>The ClientSecret value as taken from <code>OpenIdAuthenticationMechanismDefinition.clientSecret</code></p>
</li>
<li>
<p>The <code>grant_type</code> value set to the constant <code>authorization_code</code></p>
</li>
<li>
<p>The RedirectURI value as taken from <code>OpenIdAuthenticationMechanismDefinition.redirectURI</code></p>
</li>
<li>
<p>The code received from the OpenID Connect Provider in the callback request as the <code>code</code> request parameter</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>If the call to the Token endpoint is successful, it should return a "Token Response" in JSON format.</p>
</div>
<div class="paragraph">
<p>When available in the "Token Response", the optional fields "refresh_token" and "expires_in" must be stored internally.</p>
</div>
<div class="paragraph">
<p>The authentication mechanism also MUST create a <code>jakarta.security.enterprise.credential.Credential</code> instance holding this Token Response and MUST validate this token using the available <code>IdentityStoreHandler</code>.</p>
</div>
<div class="paragraph">
<p>In order to correctly validate this token, the Jakarta Security implementation MUST install an <code>IdentityStore</code> capable of validating this credential. Note that in this version of the specification the type of both the <code>Credential</code> and <code>IdentityStore</code> are implementation specific. A future version of the specification may standardise these. For this reason the implementation specific identity store is now discussed in this chapter.</p>
</div>
<div class="paragraph">
<p>The <code>IdentityStore</code> mentioned above must perform the following checks (also defined by the OpenID Connect specification):</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The <em>issuer</em> claim matches the issuer retrieved from the <code>well known openid configuration endpoint</code> or the <code>issuer</code> member of the <code>OpenIdProviderMetadata</code> construct.</p>
</li>
<li>
<p>A <em>subject</em> claim is present and contains a value.</p>
</li>
<li>
<p>The <em>audience</em> claim is present and is equal to the <code>OpenIdAuthenticationMechanismDefinition.clientId</code></p>
</li>
<li>
<p>If multiple audience values are returned by the OpenID Connect Provider, an authorized party claim (<code>azp</code>) must be present.</p>
</li>
<li>
<p>If an <em>authorized party</em> claim (<code>azp</code>) is present, it must match the <code>OpenIdAuthenticationMechanismDefinition.clientId</code></p>
</li>
<li>
<p>The <em>expiration</em> claim must be present and must be 'in the future' (a clock skew might be considered or configured in an implementation specific way)</p>
</li>
<li>
<p>The <em>issued at</em> claim must be present and must be 'in the past' (a clock skew might be considered or configured in an implementation specific way)</p>
</li>
<li>
<p>The <em>not before</em> claim can be present and if defined, must be 'in the past' (a clock skew might be considered or configured in an implementation specific way)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>For the Identity Token, the following check must be performed additionally</p>
</div>
<div class="ulist">
<ul>
<li>
<p>When <code>nonce</code> usage is configured, verify if the <code>nonce</code> value within the Identity Token is identical to the one that was specified in the authentication request.</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_caller_name_and_groups"><a class="anchor" href="#_caller_name_and_groups"></a>Caller name and groups</h5>
<div class="paragraph">
<p>A public OpenID Connect Provider generally has no knowledge about roles or groups an end-user (caller) has in a client application (relying party), but
a (private) OpenID Connect Provider operated by the same organisation may have. Therefore this specification allows groups to be provided by the client application or by the OpenID Connect Provider (or both).</p>
</div>
<div class="paragraph">
<p>Groups can be provided by the client application by means of an extra identity store with the <code>validationTypes</code> method returning <code>PROVIDE_GROUPS</code>.  Groups can be provided by the OpenID Connect Provider by means of additional claims.</p>
</div>
<div class="paragraph">
<p>The claim name that is used to define the Caller Name and optionally the Caller Groups from the OpenID Connect Provider can be defined by the following attributes:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Caller Name: <code>OpenIdAuthenticationMechanismDefinition.claimsDefinition.callerNameClaim</code></p>
</li>
<li>
<p>Caller Groups: <code>OpenIdAuthenticationMechanismDefinition.claimsDefinition.callerGroupsClaim</code>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The following logic is used to determine the value of each;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If the specified claim exists and has a non-empty value in the Access Token, this Access Token claim value is taken.</p>
</li>
<li>
<p>If not resolved yet, and the specified claim exists and has a non-empty value in the Identity Token, this Identity Token claim value is taken.</p>
</li>
<li>
<p>If not resolved yet, and the specified claim exists and has a non-empty value in the User Info Token, this User Info Token claim value is taken.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>An implementation may choose to not implement the call to the User Info Endpoint, in all cases or when a certain configuration value is set, since not all OpenID Connect Providers support this User Info Endpoint.</p>
</div>
<div class="paragraph">
<p>The Caller Name and optionally any Caller Groups provided by the OpenID Connect Provider must be present in the <code>CredentialValidationResult</code> that is returned by the implementation specific identity store that validates the <code>Credential</code> holding the Token Response as mentioned above.</p>
</div>
<div class="sect5">
<h6 id="_remembering_authentication"><a class="anchor" href="#_remembering_authentication"></a>Remembering authentication</h6>
<div class="paragraph">
<p>After the end-user (caller) has been successfully authenticated, the authentication mechanism must ensure that an authenticated session is established in a way functionally equivalent to the functionality provided by the "<a href="#_autoapplysession_annotation">AutoApplySession Annotation</a>". An implementation may, but does not have to, use that annotation to fulfill this requirement.</p>
</div>
</div>
<div class="sect5">
<h6 id="_token_expiration"><a class="anchor" href="#_token_expiration"></a>Token Expiration</h6>
<div class="paragraph">
<p>The authentication mechanism must check on each request for which there is an authenticated user if the Access Token or the Identity Token has expired.</p>
</div>
<div class="paragraph">
<p>In case a token is expired, there are 3 options:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The token is refreshed when <code>OpenIdAuthenticationMechanismDefinition.tokenAutoRefresh</code> set to <code>true</code></p>
</li>
<li>
<p>A logout takes place when <code>OpenIdAuthenticationMechanismDefinition.logout.accessTokenExpiry</code> or <code>OpenIdAuthenticationMechanismDefinition.logout.identityTokenExpiry</code> set to <code>true</code> and the Access Token respectively Identity Token is expired</p>
</li>
<li>
<p>The token expiration is ignored when none of the above conditions hold</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>In the case a refresh of the token is needed, the OpenID Connect provider refreshToken endpoint has to be called with the following parameters</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The ClientId value as taken from <code>OpenIdAuthenticationMechanismDefinition.clientId</code></p>
</li>
<li>
<p>The ClientSecret value as taken from <code>OpenIdAuthenticationMechanismDefinition.clientId</code></p>
</li>
<li>
<p>The <code>grant_type</code> value set to the constant <code>refresh_token</code></p>
</li>
<li>
<p>the <code>refresh_token</code> value set to the previously stored value from the <code>refresh_token</code> field of the Token Response</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the call is successful and a new Access Token is received, the same logic is applied as described above;</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Validate tokens</p>
</li>
<li>
<p>Store in context</p>
</li>
<li>
<p>Determine the caller Name and Caller groups values (which can lead to more or less permissions in the application)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>When the call is not successful, or when there is no previously stored <code>refresh_token</code> field of the Token Response, a logout should be initiated.</p>
</div>
</div>
<div class="sect5">
<h6 id="_logout"><a class="anchor" href="#_logout"></a>Logout</h6>
<div class="paragraph">
<p>The <code>cleanSubject</code> method of the authentication mechanism has the following requirements</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Invalidate the HTTP Session, if one is available</p>
</li>
<li>
<p>Call the EndSession endpoint of the OpenID Connect Provider if <code>OpenIdAuthenticationMechanismDefinition.logout.notifyProvider</code> is set to <code>true</code> and such EndSession endpoint is available. If <code>OpenIdAuthenticationMechanismDefinition.logout.redirectURI</code> is defined it should be passed along in this call.</p>
</li>
<li>
<p>Redirect to <code>OpenIdAuthenticationMechanismDefinition.logout.redirectURI</code> if <code>OpenIdAuthenticationMechanismDefinition.logout.notifyProvider</code> is set to <code>false</code> and <code>OpenIdAuthenticationMechanismDefinition.logout.redirectURI</code> is defined</p>
</li>
<li>
<p>Redirect to the OpenID Connect Provider Authentication endpoint for re-authentication if the previous two conditions don&#8217;t hold. Be aware that a correct <code>promptType</code> must be defined so that this option works properly. Without any prompt defined, the Openid Connect Provider can immediately redirect to the <em>callback</em>  (value of <code>OpenIdAuthenticationMechanismDefinition.redirectURI</code>) of the application and the end-user (caller) is then again authenticated within the application, effectively making logging out impossible.</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_logintocontinue_annotation"><a class="anchor" href="#_logintocontinue_annotation"></a>LoginToContinue Annotation</h4>
<div class="paragraph">
<p>The <em>LoginToContinue</em> annotation provides an application with the ability to declaratively add "login to continue" functionality to an authentication mechanism. "Login to continue" conceptually refers to the algorithm (flow) described by the numbered steps in [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>], Section 13.6.3, "Form Based Authentication".</p>
</div>
<div class="paragraph">
<p>The annotation is also used to configure the login page, error page, and redirect/forward behavior for the built-in form-based authentication mechanisms (implicitly suggesting, but not requiring, that those authentication mechanisms use the backing interceptor for this annotation, which is described below).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inherited
@InterceptorBinding
@Retention(RUNTIME)
@Target(TYPE)
public @interface LoginToContinue {

    @Nonbinding
    String loginPage() default "/login";

    @Nonbinding
    boolean useForwardToLogin() default true;

    @Nonbinding
    String useForwardToLoginExpression() default "";

    @Nonbinding
    String errorPage() default "/login-error";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container MUST provide an interceptor implementation, at priority <em>PLATFORM_BEFORE</em> + 220, that backs the <em>LoginToContinue</em> annotation and intercepts calls to the configured <em>HttpAuthenticationMechanism</em>. The interceptor MUST behave as follows when intercepting calls to the <em>HttpAuthenticationMechanism</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Intercepting <em>validateRequest()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Determine if there is any stale state in the request context, due to a previously aborted flow involving "login to continue". If so, clear the stale state.</p>
</li>
<li>
<p>Determine if this request is a new caller-initiated authentication, by calling <em>isNewAuthentication()</em> on the <em>AuthenticationParameters</em> object available from <em>HttpMessageContext</em>.</p>
<div class="ulist">
<ul>
<li>
<p>If <em>isNewAuthentication()</em> returns true, update the request state to indicate that this is a caller-initiated authentication.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the request is a caller-initiated authentication, continue with flow <em>processCallerInitiatedAuthentication</em>.</p>
</li>
<li>
<p>Otherwise, if the request is not a caller-initiated authentication, continue with flow <em>processContainerInitiatedAuthentication</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Flow processCallerInitiatedAuthentication</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Call the next <em>Interceptor</em>, and remember the resulting <em>AuthenticationStatus</em>.</p>
</li>
<li>
<p>If the result was <em>AuthenticationStatus.SUCCESS</em>, and <em>HttpMessageContext.getCallerPrincipal()</em> returns a non-null principal, clear all state.</p>
</li>
<li>
<p>Return the <em>AuthenticationStatus</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Flow processContainerInitiatedAuthentication</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Determine how far the caller is in the "login to continue" flow by comparing the request and state against the following numbered and named steps:</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><em>OnInitialProtectedURL</em>: Protected resource requested and no saved request state.</p>
</li>
<li>
<p><em>OnLoginPostback</em>: A postback after redirecting the caller in Step 1. (Note: this is not necessarily the resource the caller was redirected to&#8201;&#8212;&#8201;for example, a redirect to <em>/login</em> could result in a postback to <em>j_security_check</em>, or to <em>/login2</em>.)</p>
</li>
<li>
<p><em>OnOriginalURLAfterAuthenticate</em>: A request on the original, protected URL from Step 1, with authentication data and saved request state.</p>
</li>
</ol>
</div>
</li>
<li>
<p>If the step, as described above, can be determined, continue with the flow having the same name as that step, otherwise return the result of calling the next <em>Interceptor</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Flow OnInitialProtectedURL</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Save all request details (URI, headers, body, etc.) to the state.</p>
</li>
<li>
<p>Redirect or forward to <em>LoginToContinue.loginPage()</em>, depending on the value of the <em>useForwardToLogin()</em> attribute.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Flow OnLoginPostback</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Call the next <em>Interceptor</em>, and remember the resulting <em>AuthenticationStatus</em>.</p>
</li>
<li>
<p>If the result was <em>AuthenticationStatus.SUCCESS</em>:</p>
<div class="ulist">
<ul>
<li>
<p>If <em>HttpMessageContext.getCallerPrincipal()</em> returns <em>null</em>, return <em>AuthenticationStatus.SUCCESS</em></p>
</li>
<li>
<p>If the current request matches the saved request state (same URI, headers, etc.), return <em>AuthenticationStatus.SUCCESS</em></p>
</li>
<li>
<p>If the current request does not match the saved request state, save the authentication state (minimally, the caller principal and groups from the <em>HttpMessageContext</em>) and redirect to the full request URL as stored in the saved request state.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the result was <em>AuthenticationStatus.SEND_FAILURE</em>:</p>
<div class="ulist">
<ul>
<li>
<p>If <em>LoginToContinue.errorPage()</em> is non-null and non-empty, redirect to <em>LoginToContinue.errorPage()</em>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Return the <em>AuthenticationStatus</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Flow OnOriginalURLAfterAuthenticate</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Retrieve the saved request and authentication details.</p>
</li>
<li>
<p>Clear all state related to "login to continue".</p>
</li>
<li>
<p>Set a wrapped request into <em>HttpMessageContext</em> that provides all the original request details (headers, body, method, etc.) from the saved request state.</p>
</li>
<li>
<p>Call the <em>HttpMessageContext.notifyContainerAboutLogin()</em> method with the caller principal and groups from the saved authentication state.</p>
</li>
<li>
<p>Return <em>AuthenticationStatus.SUCCESS</em>.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Intercepting <em>secureResponse()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <em>secureResponse()</em> method SHOULD NOT be intercepted.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Intercepting <em>cleanSubject()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <em>cleanSubject()</em> method SHOULD NOT be intercepted.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>See also the <a href="#_securitycontext_authenticate_notes">SecurityContext.authenticate() Notes</a> section below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_rememberme_annotation"><a class="anchor" href="#_rememberme_annotation"></a>RememberMe Annotation</h4>
<div class="paragraph">
<p>The <em>RememberMe</em> annotation is used to configure a <em>RememberMeIdentityStore</em>, which must be provided by the application. To use <em>RememberMe</em>, the application must provide an <em>HttpAuthenticationMechanism</em> and annotate the <em>HttpAuthenticationMechanism</em> with the <em>RememberMe</em> annotation.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inherited
@InterceptorBinding
@Retention(RUNTIME)
@Target(TYPE)
public @interface RememberMe {

    @Nonbinding
    int cookieMaxAgeSeconds() default 86400; // 1 day

    @Nonbinding
    String cookieMaxAgeSecondsExpression() default "";

    @Nonbinding
    boolean cookieSecureOnly() default true;

    @Nonbinding
    String cookieSecureOnlyExpression() default "";

    @Nonbinding
    boolean cookieHttpOnly() default true;

    @Nonbinding
    String cookieHttpOnlyExpression() default "";

    @Nonbinding
    String cookieName() default "JREMEMBERMEID";

    @Nonbinding
    boolean isRememberMe() default true;

    @Nonbinding
    String isRememberMeExpression() default "";
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container MUST provide an interceptor implementation at priority <em>PLATFORM_BEFORE</em> + 210 that backs the <em>RememberMe</em> annotation and intercepts calls to the configured <em>HttpAuthenticationMechanism</em>. The interceptor MUST behave as follows when intercepting calls to the <em>HttpAuthenticationMechanism</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Intercepting <em>validateRequest()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Determine whether there is a RememberMe cookie in the request.</p>
</li>
<li>
<p>If the cookie is present:</p>
<div class="ulist">
<ul>
<li>
<p>Use it to construct a <em>RememberMeCredential</em> and call the <em>validate()</em> method of the <em>RememberMeIdentityStore</em>.</p>
</li>
<li>
<p>If the validate succeeds, call <em>HttpMessageContext.notifyContainerAboutLogin()</em>, passing the CallerPrincipal and CallerGroups returned by <em>validate()</em>.</p>
</li>
<li>
<p>If the validate fails, remove the cookie from the request.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If no cookie is present, or if the attempt to validate a cookie failed, authenticate the caller normally by calling <em>proceed()</em> on the <em>InvocationContext</em>.</p>
</li>
<li>
<p>If authentication succeeds, and the caller has requested to be remembered, as determined by evaluating the <em>isRememberMeExpression()</em>, then:</p>
<div class="ulist">
<ul>
<li>
<p>Call the <em>generateLoginToken()</em> method of the <em>RememberMeIdentityStore</em>.</p>
</li>
<li>
<p>Set the new cookie with parameters as configured on the <em>RememberMe</em> annotation.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Intercepting <em>secureResponse()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <em>secureResponse()</em> method SHOULD NOT be intercepted.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Intercepting <em>cleanSubject()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>If there is a RememberMe cookie in the request, then:</p>
<div class="ulist">
<ul>
<li>
<p>Remove the cookie.</p>
</li>
<li>
<p>Call the <em>removeLoginToken()</em> method of the <em>RememberMeIdentityStore</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>See also the description of <em>RememberMeIdentityStore</em> in Chapter 3, "<a href="identityStore.html#identity-store" class="xref page">Identity Store</a>".</p>
</div>
</div>
<div class="sect3">
<h4 id="_autoapplysession_annotation"><a class="anchor" href="#_autoapplysession_annotation"></a>AutoApplySession Annotation</h4>
<div class="paragraph">
<p>The <em>AutoApplySession</em> annotation provides a way to declaratively enable Jakarta Authentication <em>jakarta.servlet.http.registerSession</em> behavior for an authentication mechanism, and automatically apply it for every request.</p>
</div>
<div class="paragraph">
<p>The <em>jakarta.servlet.http.registerSession</em> property is described in Section 3.8.4 of [<a href="https://jakarta.ee/specifications/authentication/3.0/">AUTHENTICATION30</a>].</p>
</div>
<div class="paragraph">
<p>This annotation embodies the concept of a caller being authenticated over a series of multiple HTTP requests (together, a "session"). The built-in form-based authentication mechanisms use this same concept. It is therefore implicitly suggested, but not required, that the form-based authentication mechanisms use the backing interceptor for this annotation to establish and maintain their sessions.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Inherited
@InterceptorBinding
@Retention(RUNTIME)
@Target(TYPE)
public @interface AutoApplySession {
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The container MUST provide an interceptor implementation at priority <em>PLATFORM_BEFORE</em> + 200 that backs the <em>AutoApplySession</em> annotation and intercepts calls to the configured <em>HttpAuthenticationMechanism</em>. The interceptor MUST behave as follows when intercepting calls to the <em>HttpAuthenticationMechanism</em>:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Intercepting <em>validateRequest()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>Get the <em>HttpServletRequest</em> from the <em>HttpMessageContext</em> that is passed as an argument to <em>validateRequest()</em>.</p>
</li>
<li>
<p>Get the <em>Principal</em> from the <em>HttpServletRequest</em> (via <em>getUserPrincipal()</em>).</p>
</li>
<li>
<p>If the <em>Principal</em> is null:</p>
<div class="ulist">
<ul>
<li>
<p>Call the next <em>Interceptor</em>, and remember the resulting <em>AuthenticationStatus</em>.</p>
<div class="ulist">
<ul>
<li>
<p>If the result is <em>AuthenticationStatus.SUCCESS</em>, get the <em>Map</em> object from the <em>MessageInfo</em> in the <em>HttpMessageContext</em>, and add an entry to the <em>Map</em> with key "<em>jakarta.servlet.http.registerSession</em>" and value "<em>true</em>".</p>
</li>
</ul>
</div>
</li>
<li>
<p>Return the <em>AuthenticationStatus</em>.</p>
</li>
</ul>
</div>
</li>
<li>
<p>If the <em>Principal</em> is not null:</p>
<div class="ulist">
<ul>
<li>
<p>Create a new <em>CallerPrincipalCallback</em> instance, passing the <em>Principal</em> and client subject obtained from <em>HttpMessageContext</em> to the constructor.</p>
</li>
<li>
<p>Obtain the <em>CallbackHandler</em> from <em>HttpMessageContext</em>, and have it handle the <em>CallerPrincipalCallback</em>.</p>
</li>
<li>
<p>Return <em>AuthenticationStatus.SUCCESS</em>.</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Intercepting <em>secureResponse()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <em>secureResponse()</em> method SHOULD NOT be intercepted.</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">Intercepting <em>cleanSubject()</em></dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>The <em>cleanSubject()</em> method SHOULD NOT be intercepted.</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>See also the <a href="#_autoapplysession_notes">AutoApplySession Notes</a> section below.</p>
</div>
</div>
<div class="sect3">
<h4 id="_implementation_notes"><a class="anchor" href="#_implementation_notes"></a>Implementation Notes</h4>
<div class="paragraph">
<p>Section 14.4, item 18, of [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>] describes requirements for supporting BASIC and FORM authentication via the web.xml <em>login-config</em> element. This specification requires that implementations of BASIC and FORM be made available as <em>HttpAuthenticationMechanism</em> CDI beans. The servlet container is NOT REQUIRED to implement separate and independent mechanisms to satisfy each requirement. Instead, the container MAY choose to provide a single mechanism, for each of BASIC and FORM, that meets the requirements of both specifications; i.e., an implementation that can be configured via <em>login-config</em>, but which is also made available as an <em>HttpAuthenticationMechanism</em> if the application uses the corresponding annotation. Equally, the container is NOT REQUIRED to provide a unified implementation, and MAY satisfy the two requirements using separate, independent implementations.</p>
</div>
<div class="paragraph">
<p>An implementation of BASIC or FORM is NOT REQUIRED to support <em>IdentityStore</em> when configured via <em>login-config</em>, regardless of whether the container has provided a single mechanism or separate mechanisms to satisfy the <em>login-config</em> and <em>HttpAuthenticationMechanism</em> requirements. Implementations MAY support <em>IdentityStore</em> for all configuration methods.</p>
</div>
<div class="paragraph">
<p>If an application provides an <em>HttpAuthenticationMechanism</em>, and also configures a <em>login-config</em> element in web.xml, the container MAY fail deployment, but is NOT REQUIRED to. If the container does not fail deployment, it MUST use only the <em>HttpAuthenticationMechanism</em> to authenticate the application&#8217;s callers (i.e., it MUST ignore the <em>login-config</em> from web.xml).</p>
</div>
</div>
<div class="sect3">
<h4 id="_custom_form_notes"><a class="anchor" href="#_custom_form_notes"></a>Custom FORM Notes</h4>
<div class="paragraph">
<p>The Custom FORM variant is intended to align better with modern Jakarta EE technologies such as CDI, Jakarta Expression Language, Jakarta Bean Validation and specifically Jakarta Server Faces.</p>
</div>
<div class="paragraph">
<p>Below is an example showing how the mechanism can be used with those technologies.</p>
</div>
<div class="paragraph">
<p>Consider the following Jakarta Server Faces Facelet:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">    &lt;h:messages /&gt;

    &lt;body&gt;
        &lt;p&gt;
            Login to continue
        &lt;/p&gt;

         &lt;form jsf:id="form"&gt;
            &lt;p&gt;
                &lt;strong&gt;Username &lt;/strong&gt;
                &lt;input jsf:id="username" type="text"
                    jsf:value="#{loginBacking.username}" /&gt;
            &lt;/p&gt;
            &lt;p&gt;
                &lt;strong&gt;Password &lt;/strong&gt;
                &lt;input jsf:id="password" type="password"
                    jsf:value="#{loginBacking.password}" /&gt;
            &lt;/p&gt;
            &lt;p&gt;
                &lt;input type="submit" value="Login"
                    jsf:action="#{loginBacking.login}" /&gt;
            &lt;/p&gt;
        &lt;/form&gt;

    &lt;/body&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The "Username" and "Password" inputs are bound via expression language to properties of a named CDI bean, and the bean&#8217;s login() method is invoked to authenticate the user:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">@Named
@RequestScoped
public class LoginBacking {

    @NotNull
    private String username;

    @NotNull
    private String password;

    @Inject
    private SecurityContext securityContext;

    @Inject
    private FacesContext facesContext;

    public void login() {

        Credential credential =
            new UsernamePasswordCredential(username, new Password(password));

        AuthenticationStatus status = securityContext.authenticate(
            getRequest(facesContext),
            getResponse(facesContext),
            withParams()
                .credential(credential));

        if (status.equals(SEND_CONTINUE)) {
            facesContext.responseComplete();
        } else if (status.equals(SEND_FAILURE)) {
            addError(facesContext, "Authentication failed");
        }

    }</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_securitycontext_authenticate_notes"><a class="anchor" href="#_securitycontext_authenticate_notes"></a>SecurityContext.authenticate() Notes</h4>
<div class="paragraph">
<p>Any <em>LoginToContinue</em>-annotated <em>HttpAuthenticationMechanism</em>, as well as the two built-in FORM authentication mechanisms, can be triggered via a call to the <em>SecurityContext.authenticate()</em> method. This method is based on the <em>HttpServletRequest.authenticate()</em> method, as defined by [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>], but has been extended to support additional functionality defined by the Servlet Container Profile of [<a href="https://jakarta.ee/specifications/authentication/3.0/">AUTHENTICATION30</a>].</p>
</div>
<div class="paragraph">
<p>The extended behavior is facilitated by the <em>AuthenticationParameters</em> parameter passed to <em>SecurityContext.authenticate()</em>. <em>AuthenticationParameters</em> includes a <em>newAuthentication</em> field.</p>
</div>
<div class="paragraph">
<p>When <em>newAuthentication</em> is set to <em>true</em>, the container MUST discard any state that it holds for an <em>HttpAuthenticationMechanism</em>, and that is associated with the current caller. Specifically, this means that any associated state, such as described for the <a href="#_logintocontinue_annotation">LoginToContinue Annotation</a> above, MUST be cleared, and the request must proceed as if processing a new request.</p>
</div>
<div class="paragraph">
<p>When <em>newAuthentication</em> is set to <em>false</em>, the container MUST NOT discard any state that it holds for an <em>HttpAuthenticationMechanism</em>, and that is associated with the current caller. Instead, the container MUST resume the in-progress authentication dialog, based on the  associated state. Specifically, the container MUST:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Determine how far the caller is in the "login to continue" flow, based on the previously saved state (or lack thereof), and;</p>
</li>
<li>
<p>Continue processing from that point as it would normally do.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_autoapplysession_notes"><a class="anchor" href="#_autoapplysession_notes"></a>AutoApplySession Notes</h4>
<div class="paragraph">
<p>As an example, idiomatic code for setting the <em>jakarta.servlet.http.registerSession</em> key as per the requirements is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">httpMessageContext.getMessageInfo().getMap().put("jakarta.servlet.http.registerSession", TRUE.toString());</code></pre>
</div>
</div>
<div class="paragraph">
<p>As another example, idiomatic code for setting the <em>CallerPrincipalCallback</em> as per the requirements is:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">httpMessageContext.getHandler().handle(new Callback[] {
    new CallerPrincipalCallback(httpMessageContext.getClientSubject(), principal) }
);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_relationship_to_other_specifications"><a class="anchor" href="#_relationship_to_other_specifications"></a>Relationship to other specifications</h3>
<div class="paragraph">
<p>An <em>HttpAuthenticationMechanism</em> is a CDI bean, as defined by Jakarta Contexts and Dependency Injection spec, version 4.0 [<a href="https://jakarta.ee/specifications/cdi/4.0/">CDI40</a>].</p>
</div>
<div class="paragraph">
<p>The methods defined by the <em>HttpAuthenticationMechanism</em> closely map to the methods and semantics of a <em>ServerAuthModule</em>, as defined by the Servlet Container Profile of [<a href="https://jakarta.ee/specifications/authentication/3.0/">AUTHENTICATION30</a>]. (But an <em>HttpAuthenticationMechanism</em> is itself not a <em>ServerAuthModule</em>.) The servlet container MUST use Jakarta Authentication mechanisms to arrange for an <em>HttpAuthenticationMechanism</em> to be placed in service.</p>
</div>
<div class="paragraph">
<p>This specification mandates that when a <em>ServerAuthModule</em> is called by the Servlet container, CDI services (such as the <em>BeanManager</em>) MUST be fully available, and all scopes that are defined to be active during the <em>service()</em> method of a servlet, or during the <em>doFilter()</em> method of a servlet filter, MUST be active. Specifically this means that the request, session, and application scopes MUST be active, and that a <em>ServerAuthModule</em> method such as <em>validateRequest()</em> MUST be able to obtain a reference to the CDI <em>BeanManager</em> programmatically (for example, by doing a JNDI lookup), and MUST be able to use that reference to obtain a valid request-scoped, session-scoped, or application-scoped bean. This specification does not mandate that a <em>ServerAuthModule</em> must itself be a CDI bean, or that a <em>ServerAuthModule</em> must be injectable.</p>
</div>
<div class="paragraph">
<p>An <em>HttpAuthenticationMechanism</em> implementation is logically equivalent to a built-in authentication mechanism as defined by [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>] (i.e., HTTP Basic Authentication, HTTP Digest Authentication, Form Based Authentication, and HTTPS Client Authentication); more specifically, it corresponds to an "additional container authentication mechanism", as described in section 13.6.5 of [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>].</p>
</div>
<div class="paragraph">
<p>The BASIC and FORM authentication mechanisms as defined by this specification are logically equivalent to the similarly named authentication mechanisms in [<a href="https://jakarta.ee/specifications/servlet/6.0/">SERVLET60</a>], respectively sections 13.6.1, "HTTP Basic Authentication", and 13.6.3, "Form Based Authentication".</p>
</div>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <p>This page was built using the Antora default UI.</p>
  <p>The source code for this UI is licensed under the terms of the MPL-2.0 license.</p>
</footer>
<script id="site-script" src="../../_/js/site.js" data-ui-root-path="../../_"></script>
<script async src="../../_/js/vendor/highlight.js"></script>
  </body>
</html>
